#!/bin/bash
################################################################################
#
################################################################################

function print_usage {
    echo "Usage: `basename $0` [options] <dep-file>"
    echo "Options:"
    echo "  -o          Enable optional packages"
    echo "  -c          Check if packages are already installed from other sources; only active with option -o"
    echo "  -p          Print the dependency tree"
}

function print_blank_n {
    N=$1
    for (( i=0; i<$N; i++ ))
    do
	echo -n ' '
    done
}


function print_char_n {
    char="$1"
    N=$2
    for (( i=0; i<$N; i++ ))
    do
	echo -ne $char
    done
}

function print_dep_tree {
 
   local topdep=$1

   print_blank_n $DEP_TREE_LVL
   echo "$topdep"
   DEP_TREE_LVL=$(( DEP_TREE_LVL + 8 ))

   if [[ ! -f $topdep ]]; then
       echo "$topdep dependency file not found--assuming no dependencies"
       return
   fi

    while read l
    do 
	if [[ $l == "REQUIRED:" || -z $l ]]; then
	    print_blank_n $DEP_TREE_LVL
	    echo "$l"
	elif [[ $l == "OPTIONAL:" ]]; then
	    (( USE_OPTPKGS == 0 )) && break
	    print_blank_n $DEP_TREE_LVL
	    echo "$l"
	else
	    check_is_entry $l
	    if (( $? == 1  )); then
		print_dep_tree $l
	    else
		print_blank_n $DEP_TREE_LVL
		echo $l
	    fi
	fi
    done<$topdep
    
    DEP_TREE_LVL=$(( DEP_TREE_LVL - 8 ))
}

################################################################################
# Parses a dependency file and inserts the package name into a global dependency 
# file. Each entry is also the name of a dependency file which is recursively 
# parsed.
################################################################################
function parse_dep_file {
 
   local topdep=$1
   local dep=$2

   # First find if it is a metapackage
   check_is_metapkg $topdep
   local metapkg=$?

   if (( $metapkg == 0 )); then
       if (( $CHECK_IS_INST == 1 )); then
	   check_is_inst $topdep
	   (( $? == 1 )) && return
       fi
       # Only write the pkg name if not a metapkg
       echo $topdep >> $dep
   fi

   if [[ ! -f $topdep ]]; then
       echo "$topdep dependency file not found--assuming no dependencies"
       return
   fi

    while read l
    do 
	if [[ $l == "REQUIRED:" || -z $l ]]; then
	    /bin/true
	elif [[ $l == "OPTIONAL:" ]]; then
	    (( USE_OPTPKGS == 0 )) && break
	else
	    check_is_entry $l
	    (( $? == 1  )) && parse_dep_file $l $dep
	fi
    done<$topdep
}


function gen_sqf_file {

    local dep=$1
    local sqf=$2

    tac $dep > .$dep
    rm -f $sqf && touch $sqf

    while read l
    do
	p=$(echo $l)
	p_test=$(grep -x $p $sqf)
	if [[ -z $p_test ]]; then
	    echo $p >> $sqf
	fi
	
    done<.$dep
    rm -f .$dep
}

function check_is_metapkg {
    local topdep=$1
    local val=$(grep -w "METAPKG" $topdep)
    
    if [[ -z $val ]]; then
	return 0
    else
	return 1
    fi
}

function check_is_entry {
    local l=$1
    
    if [[ $l == "-"* || \
	$l == "#"*  || \
	$l == "METAPKG" ]]; then
	return 0
    else
	return 1
    fi
}

function check_is_inst {
    local pkg=$1
    for f in /var/log/packages/${pkg}*
    do 
	[[ ! -f $f ]] && break

	pkg_other=${f##*\/}

	pkg_info=$(get_pkg_info $pkg_other)

	name=$(echo $pkg_info | cut -d: -f1)
	ext=$(echo $pkg_info | cut -d: -f4)

	if [[ $name == $pkg && $ext != *"_SBo" ]]; then
	    echo "previous installation for $pkg found: $pkg_other"
	    return 1
	fi
    done
    return 0
}

function get_pkg_info {
    local pkg=$1
    
    ext=${pkg##*-}
    pkg=${pkg%-${ext}}

    arch=${pkg##*-}
    pkg=${pkg%-${arch}}
    
    ver=${pkg##*-}
    pkg=${pkg%-${ver}}

    name=${pkg}

    echo "$name:$ver:$arch:$ext"
}

# Set defaults
ACTION_PRINT=1
ACTION_GENSQF=2
DEP_TREE_LVL=0

USE_OPTPKGS=0
CHECK_IS_INST=0
ACTION=$ACTION_GENSQF
ARCH=$(uname -m)

# Run through the options
while (( $# > 0 )); do
    case $1 in
	"-o")
	    USE_OPTPKGS=1
	    shift 1
	    ;;
	"-p")
	    ACTION=$ACTION_PRINT
	    shift 1
	    ;;
	"-c")
	    CHECK_IS_INST=1
	    shift 1
	    ;;
	*)
	    break
    esac
done

if (( $# != 1 )); then
    print_usage
    exit 1
fi

TOPDEP="$1"
DEP="dep"
SQF="$1.sqf"

rm -f $DEP && touch $DEP
rm -f $SQF

if (( $ACTION == $ACTION_PRINT )); then
    print_dep_tree $TOPDEP
else
    parse_dep_file $TOPDEP $DEP
    gen_sqf_file $DEP $SQF
fi

rm -f $DEP
