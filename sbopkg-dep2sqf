#!/bin/bash
################################################################################
#
################################################################################

function print_usage {
    echo "Usage: `basename $0` [options] <dep-file>"
    echo "Options:"
    echo "  -C          Check if packages are already installed"
    echo "  -N          Disable recursive parsing of dep file (does not add dependencies; does"
    echo "              add build options"
    echo "  -P          Select packages which rely on all a particular package or meta package"
    echo "              Enables option -N (thus assumes all dependencies are met; used for rebuilding"
    echo "              parent pacakges; this option respects option -o"
    echo "  -R          Review the package README, info, and dep files"
    echo "  -c          Check if packages are already installed from non-SBo sources"
    echo "  -d          Generates the package dependency and parent databases ($DEPDB and $PARENTDB,"
    echo "              the respectively); the databases are generated only if they are older than"
    echo "              $DB_TIMEOUT (seconds); use option -f to force them to be generated; this option"
    echo "              respects option -o"
    echo "  -f          Force the generation of the dependency and parent databases; used with options"
    echo "              -P and -d"
    echo "  -h          Show this information"
    echo "  -l          Print the sqf package list to stdout (build options are not included)"
    echo "  -o          Enable optional packages"
    echo "  -p          Print the dependency tree (does not generate sqf file)"
    echo "  -r          Generates sqf file to remove a package and dependencies"
}

function print_blank_n {
    N=$1
    for (( i=0; i<$N; i++ ))
    do
	echo -n ' '
    done
}


function print_char_n {
    char="$1"
    N=$2
    for (( i=0; i<$N; i++ ))
    do
	echo -ne $char
    done
}

function print_dep_tree {
    
    local topdep=$1

    [[ ! -f $topdep ]] && return
    
    print_blank_n $DEP_TREE_LVL
    echo "$topdep"
    DEP_TREE_LVL=$(( DEP_TREE_LVL + 8 ))

    while read l
    do 
	if [[ $l == "REQUIRED:" || -z $l ]]; then
	    print_blank_n $DEP_TREE_LVL
	    echo "$l"
	elif [[ $l == "OPTIONAL:" ]]; then
	    (( USE_OPTPKGS == 0 )) && break
	    print_blank_n $DEP_TREE_LVL
	    echo "$l"
	elif [[ $l == "BUILDOPTS:" ]]; then
	    break
	else    
	    if check_is_entry $l; then
		print_dep_tree $l
	    else
		print_blank_n $DEP_TREE_LVL
		echo $l
	    fi
	fi
    done <$topdep
    
    DEP_TREE_LVL=$(( DEP_TREE_LVL - 8 ))
}

################################################################################
# 
################################################################################
function sanitize_line {
    local line="$1"
    echo ${line%%#*}
}

################################################################################
# 
################################################################################
function load_pkglist_array {
    if (( ${#PKGLIST_ARRAY[@]} == 0 )); then
	PKGLIST_ARRAY=$(cat $PKGLIST)
    fi
}

################################################################################
# Prints the info and README of the package as found in the sbopkg repository
################################################################################
function print_pkg_info {
    local pkg=$1

    border1="================================================================================"
    border2="::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
    border3="--------------------------------------------------------------------------------"

    ( 
    # Should only be one found, but putting in loop in case more are found
    for f in `find $SBOPKG_REPO -name $pkg -type d`
    do
	echo $border1
	echo "$f"
	echo $border1
	echo 
	echo $border2
	echo "README"
	echo $border2
	cat $f/README
	echo
	echo $border2
	echo "$pkg.info"
	echo $border2
	cat $f/$pkg.info
	echo
    done

    echo $border1
    echo "$pkg"
    echo $border1
    echo 
    cat $pkg
    echo
        
    ) | $PAGER
}

declare -i dep_count=0

################################################################################
# Parses a dependency file and inserts the package name into a global dependency 
# file. Each entry is also the name of a dependency file which is recursively 
# parsed.
################################################################################
function parse_dep_file {
    
    local topdep=$1
    local dep=$2

    local block=0

    (( dep_count++ ))
    
    # First find if it is not a metapackage 
    if ! check_is_metapkg $topdep; then
	if (( $CHECK_INST == 1 && dep_count != 1 )); then
	    check_is_inst $topdep $CHECK_INST_SBO_ONLY && return
	fi

	if ! check_is_pkg $topdep; then
	    echo -en "${COLOR_WARN}[WARN]${COLOR_END} "
	    echo -n "$topdep not in $PKGLIST: "
	    request_pkg_add $topdep
	fi

	if ! check_is_reviewed $topdep; then
	    echo -en "${COLOR_WARN}[WARN]${COLOR_END} "
	    echo "$topdep has not been reviewed"
	fi

	# Only write the pkg name if not a metapkg
	echo "$topdep $(get_buildopts $topdep)" >> $dep

	(( NO_DEPS == 1 )) && return
    fi

    if [[ ! -f $topdep ]]; then
	echo -en "${COLOR_WARN}[WARN]${COLOR_END} "
	echo "$topdep dependency file not found--assuming no dependencies"
	return
    fi
    
    local in_block=0
    local l
    while read l
    do
	# Trim inline comments and whitespace
	l=$(sanitize_line "$l")

	[[ -z $l ]] && continue
	
	if [[ $l == "REQUIRED:" ]]; then
	    in_block=REQUIRED_BLOCK
	    continue
	elif [[ $l == "OPTIONAL:" ]]; then
	    in_block=OPTIONAL_BLOCK
	    continue
	elif [[ $l == "BUILDOPTS:" ]]; then
	    in_block=BUILDOPTS_BLOCK
	    continue
	fi
	
	# Only parse recursively for required or optional blocks
	if (( in_block == REQUIRED_BLOCK )) || \
           (( in_block == OPTIONAL_BLOCK && USE_OPTPKGS == 1 )); then

	    if check_is_entry $l; then 
	       if (( PARSE_DEP_RECURSIVE == 1 )); then
		   parse_dep_file $l $dep
	       else
		   echo "$l $(get_buildopts $l)" >> $dep
	       fi
	   fi
	fi

    done <$topdep
}

################################################################################
#
################################################################################
function get_buildopts {

    local topdep=$1

    [[ ! -f $topdep ]] && return

    (( USE_BUILDOPTS == 0 )) && return

    # Get the line number of the BUILDOPTS
    local n=$(grep -nx "BUILDOPTS:" $topdep | cut -d: -f1)
    [[ -z $n ]] && return

    # Extract only the build options and down
    tail -n +$((n+1)) $topdep > .buildopts

    local buildopts=""
    while read l
    do
	# Trim inline comments and whitespace
	l=$(sanitize_line "$l")
	if [[ $l == "OPTIONAL:" || $l == "REQUIRED:" ]]; then
	    break
	else
	    if check_is_entry "$l"; then

		
		buildopts="$buildopts $l"
	    fi
	fi
    done <.buildopts

    rm -f .buildopts

    [[ ! -z $buildopts ]] && buildopts="|$buildopts"
    echo "$buildopts"
    
}

################################################################################
#
################################################################################
function __gen_sqf {

    local dep=$1
    local sqf=$2

    tac $dep > .$dep
    rm -f $sqf && touch $sqf

    while read l
    do
	p=$(echo "$l")
	p_test=$(grep -x "$p" $sqf)
	if [[ -z $p_test ]]; then
	    echo "$p" >> $sqf
	fi
	
    done <.$dep
    rm -f .$dep
}


################################################################################
#
################################################################################
function gen_sqf {

    local dep=$1
    local sqf=$2

    __gen_sqf $dep $sqf

    echo -e "${COLOR_OK}[OK]${COLOR_END} $sqf generated"
}

################################################################################
#
################################################################################
function gen_sqf_list {

    local dep=$1
    local sqf=$2
    local -i n=0
    
    __gen_sqf $dep $sqf

    while read l
    do
	(( n++ ))
	p=$(echo $l | cut -d'|' -f1)
	echo -n "$p "
    done<$sqf
    (( n > 0 )) && echo
    
    rm -f $sqf
}

################################################################################
#
################################################################################
function gen_sqf_rm {

    local dep=$1
    local sqf=$2

    local pkg=$(tail -n 1 $sqf)
    local is_needed=0

    tac $sqf > .tmp
    rm -f $sqf

    sqf="rm-${sqf}"
    rm -f $sqf

    while read p
    do
	p=$(echo $p | cut -d'|' -f1)

	local remove=0

	# Check only SBo packages 
	if check_is_inst $p 1 1> /dev/null; then # Is installed
	    remove=1
	    # Loop through the package list seeing if this packages is needed
	    while read pl
	    do
		[[ $p == $pl ]] && continue
		# Check if it is a package in the queue file
		[[ ! -z $(grep $pl .tmp) ]] && continue

		if [[ ! -z $(grep -x $p $pl) ]]; then
		    # Other package needs this one
		    # Check only SBo packages		    
		    if check_is_inst $pl 1 1> /dev/null; then
			echo -en "${COLOR_FAIL}[KEEP]${COLOR_END} " > /dev/stderr
			echo "$p (needed at least by $pl)" > /dev/stderr
			remove=0

			# If we cannot remove the target package, then break completely out and terminate
			[[ $p == $pkg ]] && break 2

			break
		    fi
		fi
	    done<$PKGLIST
	fi


	if (( remove == 1 )); then
	    echo -e "${COLOR_OK}[RM]${COLOR_END} $p"
	    echo $p >> $sqf
	fi

    done <.tmp

    rm -f .tmp

    if [[ -f $sqf ]]; then
	echo -e "${COLOR_OK}[OK]${COLOR_END} $sqf generated"
    else
	echo -e "${COLOR_FAIL}[FAIL]${COLOR_END} $sqf not generated" > /dev/stderr
    fi
}

################################################################################
# Generates the parent database for all packages in PKGLIST
################################################################################
function gen_parentdb {
    local force=$1

    if (( force == 0 )) && [[ -f $PARENTDB ]]; then
	local cur_time=$(date +%s)
	local db_time=$(stat -c %Y $PARENTDB)

	(( cur_time - db_time <= DB_TIMEOUT )) && return
    fi

    gen_depdb $force
    
    echo -n > $PARENTDB    
    load_pkglist_array
    
    local p
    local parent
    for p in ${PKGLIST_ARRAY[@]}
    do
	parent=$(grep -w $p $DEPDB | cut -d: -f1 | sed "/^${p}\b/Id")
	echo $(echo $p: ${parent[@]}) >> $PARENTDB
    done

    echo -e "${COLOR_INFO}[INFO]${COLOR_END} $PARENTDB created"            
}

################################################################################
#
################################################################################
function gen_depdb {
    local force=$1

    if (( force == 0 )) && [[ -f $DEPDB ]]; then
	local cur_time=$(date +%s)
	local db_time=$(stat -c %Y $DEPDB)

	(( cur_time - db_time <= DB_TIMEOUT )) && return
    fi

    echo -n > $DEPDB
    load_pkglist_array

    local no_deps=$NO_DEPS
    local buildopts=$USE_BUILDOPTS

    NO_DEPS=0
    USE_BUILDOPTS=0

    local p
    local d
    for p in ${PKGLIST_ARRAY[@]}
    do
	echo -n > .p
	parse_dep_file $p .p
	
	d=$(echo `tail -n +2 .p`)
	echo "$p: $d" >> $DEPDB
    done
    rm -f .p

    NO_DEPS=$no_deps
    USE_BUILDOPTS=$buildopts

    echo -e "${COLOR_INFO}[INFO]${COLOR_END} $DEPDB created"        
}

################################################################################
#
################################################################################
function gen_db {
    local force=$1
    gen_parentdb $force # Generates DEPDB also
}

################################################################################
#
################################################################################
function gen_metapkg_wparents {
    local dep="$1"
    local dep_wparents="$2"

    load_pkglist_array
    gen_db $FORCE_GENDB 
    
    # Disable build opts and following dependences
    local buildopts=$USE_BUILDOPTS
    local no_deps=$NO_DEPS
    
    USE_BUILDOPTS=0
    NO_DEPS=1
    
    echo -n > .pkglist
    parse_dep_file $dep .pkglist

    echo -n > .parentlist
    local p
    # For each package in the list, get all of the parents
    while read p 
    do
	parent=$(grep -w "^$p:" $PARENTDB | cut -d: -f2)
	[[ -z $parent ]] && continue

	for r in ${parent[@]}
	do
	    echo "${r}" >> .parentlist
	done
	#echo "${p}" >> $dep_wparents
    done<.pkglist

    cat > .meta <<EOF
METAPKG
REQUIRED:
EOF
    # Append the parent and pkg lists and remove duplicates
    cat .parentlist .pkglist | awk '!seen[$0]++' >> .meta

    # Enable dependencies to get full tree    
    NO_DEPS=0 
    # Generate dep files for the full meta package
    echo -n > .full_pkglist
    parse_dep_file .meta .full_pkglist

    # We put the full package list in reverse order since the
    # recursive parsing of the meta package (containing the parents
    # and original meta package list) has the correct dependency order
    # starting with the end of the file. Thus reversing the order and
    # retaining only the first instance of a each package ensures that
    # when removing duplicates we retain the correct dependency
    # order. The package list is then put back into the meta package
    # order (parent then dependencies) which is then processed to
    # obtain the final meta package
    tac .full_pkglist | awk '!seen[$0]++' | tac > .p
    mv .p .full_pkglist

    # Purge the full package list of packages that are not in the .meta
    # file. The .meta file contains the list of all the original
    # packages along with all of the corresponding parents.
    echo -n > .pkglist
    while read p
    do
	[[ ! -z $(grep -w ^$p .meta) ]] && \
	    echo $p >> .pkglist
    done<.full_pkglist

    cat > $dep_wparents <<EOF
METAPKG
REQUIRED:
EOF
    cat .pkglist >> $dep_wparents
    
    # Restore the original build options
    USE_BUILDOPTS=$buildopts
    NO_DEPS=$no_deps
}


################################################################################
#
################################################################################
function check_is_metapkg {
    local topdep=$1
    local val=$(grep -w "METAPKG" $topdep 2> /dev/null)
    
    if [[ -z $val ]]; then
	return 1
    else
	return 0
    fi
}

################################################################################
#
################################################################################
function check_is_entry {
    local l="$1"
    
    if [[ -z $l || \
		$l == "-"* || \
		$l == "#"*  || \
		$l == "METAPKG" ]]; then
	return 1
    else
	return 0
    fi
}

################################################################################
#
################################################################################
function check_is_inst {
    local pkg=$1
    local sbo_only=$2

    for f in /var/log/packages/${pkg}*
    do 
	[[ ! -f $f ]] && break

	pkg_other=${f##*\/}

	pkg_info=$(get_pkg_info $pkg_other)

	name=$(echo $pkg_info | cut -d: -f1)
	ext=$(echo $pkg_info | cut -d: -f4)

	if [[ $name == $pkg ]]; then

	    if [[ (( $sbo_only == 0 )) && $ext == *${SBO_TAG}  ]]; then
		continue
	    elif [[ (( $sbo_only == 1 )) && $ext != *${SBO_TAG} ]]; then
		continue
	    fi

	    echo -ne "${COLOR_INFO}[INFO]${COLOR_END} "
	    echo "installation of $pkg found: $pkg_other"
	    return 0

	fi
    done
    return 1
}

################################################################################
# Check if package is a dependency of an installed package
################################################################################
function check_is_ext_dep {
    local pkg=$1

    for p in `grep -H ^$pkg *`
    do
	echo $p
    done
}

################################################################################
# Check if argument is a package by searching the PKGLIST file
################################################################################
function check_is_pkg {
    local pkg=$1
    if [[ -z $(grep -x $pkg $PKGLIST) ]]; then
	return 1
    else
	return 0
    fi
}
    
################################################################################
# Check package has been reviewed by searching the REVIEWED file
################################################################################
function check_is_reviewed {
    local pkg=$1
    if [[ -z $(grep -x $pkg $REVIEWED) ]]; then
	return 1
    else
	return 0
    fi
}


################################################################################
#
################################################################################
function get_pkg_info {
    local pkg=$1
    
    ext=${pkg##*-}
    pkg=${pkg%-${ext}}

    arch=${pkg##*-}
    pkg=${pkg%-${arch}}
    
    ver=${pkg##*-}
    pkg=${pkg%-${ver}}

    name=${pkg}

    echo "$name:$ver:$arch:$ext"
}

################################################################################
#
################################################################################
function request_pkg_add {  
    local pkg="$1"

    echo -n "add $pkg? (y/n): "
    read -u 1 ans

    if [[ "$ans" == "y" ]]; then
	echo -en "${COLOR_INFO}[INFO]${COLOR_END} "
	echo "$pkg added"

	echo "$1" >> $PKGLIST
	sort -n $PKGLIST > .p
	mv .p $PKGLIST
    else
	echo -en "${COLOR_FAIL}[FAIL]${COLOR_END} " > /dev/stderr
	echo "not adding required $pkg" > /dev/stderr
	exit 1
    fi   
}

################################################################################
#
################################################################################
function request_reviewed_add {  
    local pkg="$1"

    echo -n "add $pkg to $REVIEWED? (y/n): "
    read -u 1 ans

    if [[ "$ans" == "y" ]]; then
	echo -en "${COLOR_INFO}[INFO]${COLOR_END} "
	echo "$pkg added to REVIEWED"

	echo "$1" >> $REVIEWED
	sort -n $REVIEWED > .p
	mv .p $REVIEWED
    # else
    # 	echo -en "${COLOR_FAIL}[FAIL]${COLOR_END} " > /dev/stderr
    # 	echo "not adding required $pkg" > /dev/stderr
    # 	exit 1
    fi   
}

BLACK="01;30"
RED="01;31"
GREEN="01;32"
YELLOW="01;33"
BLUE='01;34'
MAGENTA="01;35"
CYAN="01;36"

COLOR_OK="\033[${GREEN}m"
COLOR_INFO="\033[${YELLOW}m"
COLOR_WARN="\033[${MAGENTA}m"
COLOR_FAIL="\033[${RED}m"
COLOR_END="\033[0m"

# Environment
PAGER=${PAGER:-less -r}

# Parameters
SBOPKG_REPO="/var/lib/sbopkg/SBo-git"
SBO_TAG="_SBo"
PKGLIST="PKGLIST"
REVIEWED="REVIEWED"
PARENTDB="PARENTDB"
DEPDB="DEPDB"
REQUIRED_BLOCK=1
OPTIONAL_BLOCK=2
BUILDOPTS_BLOCK=3

# Set defaults
ACTION_PRINT=1
ACTION_GENSQF=2
ACTION_GENSQF_RM=3
ACTION_GENSQF_LIST=4
ACTION_REVIEW_PKG=5
ACTION_GENDB=6
ACTION_PROCESS_PARENTS=7
DEP_TREE_LVL=0

USE_OPTPKGS=0
USE_BUILDOPTS=1
CHECK_INST_EXT=0
CHECK_INST_ALL=0
CHECK_INST=0
CHECK_INST_SBO_ONLY=""
NO_DEPS=0
PARSE_DEP_RECURSIVE=1
FORCE_GENDB=0
DB_TIMEOUT=$(( 60 * 30 )) # 30 min
# Default action
ACTION=$ACTION_GENSQF
ARCH=$(uname -m)

# Run through the options
while (( $# > 0 )); do
    case $1 in
	"-C")
	    CHECK_INST_ALL=1
	    shift 1
	    ;;
	"-N")
	    NO_DEPS=1
	    shift 1
	    ;;
	"-P")
	    ACTION=$ACTION_PROCESS_PARENTS
	    shift 1
	    ;;
	"-R")
	    ACTION=$ACTION_REVIEW_PKG
	    shift 1
	    ;;
	"-c")
	    CHECK_INST_EXT=1
	    shift 1
	    ;;
	"-d")
	    ACTION=$ACTION_GENDB
	    shift 1
	    ;;
	"-f")
	    FORCE_GENDB=1
	    shift 1
	    ;;
	"-h")
	    print_usage
	    exit 0
	    ;;
	"-l")
	    ACTION=$ACTION_GENSQF_LIST
	    shift 1
	    ;;	
	"-o")
	    USE_OPTPKGS=1
	    shift 1
	    ;;
	"-p")
	    ACTION=$ACTION_PRINT
	    shift 1
	    ;;
	"-r")
	    ACTION=$ACTION_GENSQF_RM
	    shift 1
	    ;;
	"-"*)
	    echo "invalid option $1" >&2
	    exit 1
	    ;;
	*)
	    break
    esac
done

if (( $# != 1 )) && \
   (( ACTION != ACTION_GENDB )); then
    print_usage
    exit 1
fi

# Manually setting the installation checks if we are generating a 
if (( $ACTION == $ACTION_GENSQF_RM )); then
    if (( $CHECK_INST_ALL == 1 )); then
	echo -en "${COLOR_INFO}[INFO]${COLOR_END} "
	echo "ignoring option -C"
    fi
    
    CHECK_INST_EXT=1
    CHECK_INST_ALL=0
fi

# Set the installation check flags 
if (( $CHECK_INST_EXT == 1 )); then
    CHECK_INST=1
    CHECK_INST_SBO_ONLY=0 # Exclude SBo packages
fi
if (( $CHECK_INST_ALL == 1 )); then
    if (( $CHECK_INST_EXT == 1 )); then
	echo -en "${COLOR_INFO}[INFO]${COLOR_END} "
	echo "ignoring option -c"
	CHECK_INST_EXT=0
    fi
    CHECK_INST=1
    CHECK_INST_SBO_ONLY="" # No setting for SBo only, so this will include all packages
fi

TOPDEP="$1"
DEP="dep"
SQF="$1.sqf"

rm -f $DEP && touch $DEP
rm -f $SQF

# If we are processing the parents
if (( ACTION == ACTION_PROCESS_PARENTS )); then
    if (( NO_DEPS == 0 )); then
    	echo -e "${COLOR_INFO}[INFO]${COLOR_END} not processing dependencies"
    	NO_DEPS=1
    fi
    gen_metapkg_wparents $TOPDEP $TOPDEP-wparents &&
    echo -e "${COLOR_OK}[OK]${COLOR_END} $TOPDEP-wparents meta package dep file created"
    TOPDEP=$TOPDEP-wparents
    SQF="${TOPDEP}.sqf"

    # Set the gensqf action to generate the sqf file
    ACTION=$ACTION_GENSQF
fi
   
if (( ACTION == ACTION_GENDB )); then
    gen_db $FORCE_GENDB
    echo -e "${COLOR_OK}[OK]${COLOR_END} package databases created"    
elif (( ACTION == ACTION_PRINT )); then
    print_dep_tree $TOPDEP
elif (( ACTION == ACTION_GENSQF_RM )); then
    # Enable external installed checking
    parse_dep_file $TOPDEP $DEP 1> /dev/null
    gen_sqf $DEP $SQF 1> /dev/null
    gen_sqf_rm $DEP $SQF
elif (( ACTION == ACTION_GENSQF_LIST )); then
    parse_dep_file $TOPDEP $DEP
    gen_sqf_list $DEP .$SQF
elif (( ACTION ==ACTION_REVIEW_PKG )); then
    print_pkg_info $TOPDEP
    ! check_is_reviewed $TOPDEP && request_reviewed_add $TOPDEP
else
    parse_dep_file $TOPDEP $DEP
    gen_sqf $DEP $SQF
fi

rm -f $DEP
