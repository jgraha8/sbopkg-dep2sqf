#!/bin/bash
################################################################################
#
################################################################################

function print_usage {
    echo "Usage: `basename $0` [options] <dep-file>"
    echo "Options:"
    echo "  -c          Check if packages are already installed from other sources; only active with option -o"
    echo "  -h          Show this information"
    echo "  -o          Enable optional packages"
    echo "  -p          Print the dependency tree (does not generate sqf file)"
    echo "  -r          Generates sqf file to remove a package and dependencies"
}

function print_blank_n {
    N=$1
    for (( i=0; i<$N; i++ ))
    do
	echo -n ' '
    done
}


function print_char_n {
    char="$1"
    N=$2
    for (( i=0; i<$N; i++ ))
    do
	echo -ne $char
    done
}

function print_dep_tree {
    
    local topdep=$1

    [[ ! -f $topdep ]] && return
    
    print_blank_n $DEP_TREE_LVL
    echo "$topdep"
    DEP_TREE_LVL=$(( DEP_TREE_LVL + 8 ))

    while read l
    do 
	if [[ $l == "REQUIRED:" || -z $l ]]; then
	    print_blank_n $DEP_TREE_LVL
	    echo "$l"
	elif [[ $l == "OPTIONAL:" ]]; then
	    (( USE_OPTPKGS == 0 )) && break
	    print_blank_n $DEP_TREE_LVL
	    echo "$l"
	elif [[ $l == "BUILDOPTS:" ]]; then
	    break
	else
	    check_is_entry $l 
	    if (( $? == 1  )); then
		print_dep_tree $l
	    else
		print_blank_n $DEP_TREE_LVL
		echo $l
	    fi
	fi
    done <$topdep
    
    DEP_TREE_LVL=$(( DEP_TREE_LVL - 8 ))
}

################################################################################
# Parses a dependency file and inserts the package name into a global dependency 
# file. Each entry is also the name of a dependency file which is recursively 
# parsed.
################################################################################
function parse_dep_file {
    
    local topdep=$1
    local dep=$2

    local block=0

    # First find if it is a metapackage
    check_is_metapkg $topdep
    local metapkg=$?

    if (( $metapkg == 0 )); then
	if (( $CHECK_IS_INST_EXT == 1 )); then
	    check_is_inst $topdep 0 # check only non-SBo packages
	    (( $? == 1 )) && return
	fi
	# Only write the pkg name if not a metapkg
	echo "$topdep $(get_buildopts $topdep)" >> $dep
    fi

    if [[ -z $(grep -x $topdep $PKGLIST) ]]; then
	echo -en "${COLOR_FAIL}[FAIL]${COLOR_END} " > /dev/stderr
	echo "$topdep not in $PKGLIST" > /dev/stderr
	exit 1
    fi

    if [[ ! -f $topdep ]]; then
	echo -en "${COLOR_WARN}[WARN]${COLOR_END} "
	echo "$topdep dependency file not found--assuming no dependencies"
	return
    fi
    
    local in_block=0
    while read l
    do
	if [[ $l == "REQUIRED:" || -z $l ]]; then
	    in_block=REQUIRED_BLOCK
	    continue
	elif [[ $l == "OPTIONAL:" ]]; then
	    in_block=OPTIONAL_BLOCK
	    continue
	elif [[ $l == "BUILDOPTS:" ]]; then
	    in_block=BUILDOPTS_BLOCK
	    continue
	fi

	# Only parse recursively for required or optional blocks
	if (( in_block == REQUIRED_BLOCK )) || \
	    (( in_block == OPTIONAL_BLOCK && USE_OPTPKGS == 1 )); then
	    check_is_entry $l
	    (( $? == 1  )) && parse_dep_file $l $dep
	fi

    done <$topdep
}

################################################################################
#
################################################################################
function get_buildopts {

    local topdep=$1

    [[ ! -f $topdep ]] && return

    # Get the line number of the BUILDOPTS
    local n=$(grep -nx "BUILDOPTS:" $topdep | cut -d: -f1)
    [[ -z $n ]] && return

    # Extract only the build options and down
    tail -n +$((n+1)) $topdep > .buildopts

    local buildopts=""
    while read l
    do
	if [[ $l == "OPTIONAL:" || $l == "REQUIRED:" ]]; then
	    break
	else
	    check_is_entry "$l"
	    (( $? == 1 )) && buildopts="$buildopts $l"
	fi
    done <.buildopts

    rm -f .buildopts

    [[ ! -z $buildopts ]] && buildopts="|$buildopts"
    echo "$buildopts"
    
}

################################################################################
#
################################################################################
function gen_sqf_file {

    local dep=$1
    local sqf=$2

    tac $dep > .$dep
    rm -f $sqf && touch $sqf

    while read l
    do
	p=$(echo "$l")
	p_test=$(grep -x "$p" $sqf)
	if [[ -z $p_test ]]; then
	    echo "$p" >> $sqf
	fi
	
    done <.$dep
    rm -f .$dep

    echo -e "${COLOR_OK}[OK]${COLOR_END} $sqf generated"
}

################################################################################
#
################################################################################
function gen_sqf_rm_file {

    local dep=$1
    local sqf=$2

    local pkg=$(tail -n 1 $sqf)
    local is_needed=0

    tac $sqf > .tmp
    rm -f $sqf

    sqf="rm-${sqf}"
    rm -f $sqf

    while read p
    do
	p=$(echo $p | cut -d'|' -f1)


	local remove=0

	# Check if the pkg is installed
	check_is_inst $p 1 1> /dev/null # Check only SBo packages
	if (( $? == 1 )); then # Is installed
	    remove=1
	    # Loop through the package list seeing if this packages is needed
	    while read pl
	    do
		[[ $p == $pl ]] && continue
		# Check if it is a package in the queue file
		local test=$(grep $pl .tmp)
		[[ ! -z $test ]] && continue

		test=$(grep -x $p $pl)
		if [[ ! -z $test ]]; then
		    check_is_inst $pl 1 1> /dev/null # Check only SBo packages
		    # Other package needs this one
		    if (( $? == 1 )); then
			echo -en "${COLOR_FAIL}[KEEP]${COLOR_END} " > /dev/stderr
			echo "$p (needed at least by $pl)" > /dev/stderr
			remove=0
			break
		    fi
		fi
	    done<$PKGLIST
	fi


	if (( remove == 1 )); then
	    echo -e "${COLOR_OK}[RM]${COLOR_END} $p"
	    echo $p >> $sqf
	fi

    done <.tmp

    rm -f .tmp

    if [[ -f $sqf ]]; then
	echo -e "${COLOR_OK}[OK]${COLOR_END} $sqf generated"
    else
	echo -e "${COLOR_FAIL}[FAIL]${COLOR_END} $sqf not generated" > /dev/stderr
    fi
}


################################################################################
#
################################################################################
function check_is_metapkg {
    local topdep=$1
    local val=$(grep -w "METAPKG" $topdep 2> /dev/null)
    
    if [[ -z $val ]]; then
	return 0
    else
	return 1
    fi
}

################################################################################
#
################################################################################
function check_is_entry {
    local l="$1"
    
    if [[ -z $l || \
	$l == "-"* || \
	$l == "#"*  || \
	$l == "METAPKG" ]]; then
	return 0
    else
	return 1
    fi
}

################################################################################
#
################################################################################
function check_is_inst {
    local pkg=$1
    local sbo_only=$2

    for f in /var/log/packages/${pkg}*
    do 
	[[ ! -f $f ]] && break

	pkg_other=${f##*\/}

	pkg_info=$(get_pkg_info $pkg_other)

	name=$(echo $pkg_info | cut -d: -f1)
	ext=$(echo $pkg_info | cut -d: -f4)

	if [[ $name == $pkg ]]; then

	    [[ -z $sbo_only ]] && return 1

	    if [[ (( $sbo_only == 0 )) && $ext != *"_SBo"  ]]; then
		echo -ne "${COLOR_INFO}[INFO]${COLOR_END} "
		echo "external installation of $pkg found: $pkg_other"
		return 1
	    fi

	    if [[ (( $sbo_only == 1 )) && $ext == *"_SBo" ]]; then
		echo -ne "${COLOR_INFO}[INFO]${COLOR_END} "
		echo "installation of $pkg found: $pkg_other"
		return 1
	    fi

	fi
    done
    return 0
}

################################################################################
# Check if package is a dependency of an installed package
################################################################################
function check_is_ext_dep {
    local pkg=$1

    for p in `grep -H ^$pkg *`
    do
	echo $p
    done
}

################################################################################
#
################################################################################
function get_pkg_info {
    local pkg=$1
    
    ext=${pkg##*-}
    pkg=${pkg%-${ext}}

    arch=${pkg##*-}
    pkg=${pkg%-${arch}}
    
    ver=${pkg##*-}
    pkg=${pkg%-${ver}}

    name=${pkg}

    echo "$name:$ver:$arch:$ext"
}

BLACK="01;30"
RED="01;31"
GREEN="01;32"
YELLOW="01;33"
BLUE='01;34'
MAGENTA="01;35"
CYAN="01;36"

COLOR_OK="\033[${GREEN}m"
COLOR_WARN="\033[${YELLOW}m"
COLOR_INFO="\033[${YELLOW}m"
COLOR_FAIL="\033[${RED}m"
COLOR_END="\033[0m"

# Parameters
PKGLIST="PKGLIST"
REQUIRED_BLOCK=1
OPTIONAL_BLOCK=2
BUILDOPTS_BLOCK=3

# Set defaults
ACTION_PRINT=1
ACTION_GENSQF=2
ACTION_GENSQF_RM=3
DEP_TREE_LVL=0

USE_OPTPKGS=0
CHECK_IS_INST_EXT=0
# Default action
ACTION=$ACTION_GENSQF
ARCH=$(uname -m)

# Run through the options
while (( $# > 0 )); do
    case $1 in
	"-c")
	    CHECK_IS_INST_EXT=1
	    shift 1
	    ;;
	"-h")
	    print_usage
	    exit 0
	    ;;
	"-o")
	    USE_OPTPKGS=1
	    shift 1
	    ;;
	"-p")
	    ACTION=$ACTION_PRINT
	    shift 1
	    ;;
	"-r")
	    ACTION=$ACTION_GENSQF_RM
	    shift 1
	    ;;
	*)
	    break
    esac
done

if (( $# != 1 )); then
    print_usage
    exit 1
fi

TOPDEP="$1"
DEP="dep"
SQF="$1.sqf"

rm -f $DEP && touch $DEP
rm -f $SQF

if (( $ACTION == $ACTION_PRINT )); then
    print_dep_tree $TOPDEP
elif (( $ACTION == $ACTION_GENSQF_RM )); then
    # Enable external installed checking
    CHECK_IS_INST_EXT=1
    parse_dep_file $TOPDEP $DEP 1> /dev/null
    gen_sqf_file $DEP $SQF 1> /dev/null
    gen_sqf_rm_file $DEP $SQF
else
    parse_dep_file $TOPDEP $DEP
    gen_sqf_file $DEP $SQF
fi

rm -f $DEP
